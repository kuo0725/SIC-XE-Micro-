# 讀取檔案
f = open('./Input.txt', 'r')
Input = f.readlines()
f.close()

# 處理第一行，初始化 main 列表
temp = Input[0].replace('\n', '').split(' ')
#將第一行的內容去除換行符號後，以空格分割成列表。
if (len(temp) == 3):#檢查 temp 列表的長度是否為 3
    main = [[5, temp[0], temp[1], temp[2]]]
    #第一行有三個元素，將這三個元素分別填入 main 列表的 [5, temp[0], temp[1], temp[2]]

else:
    main = [[5, '', temp[0], temp[1]]]
    #第一行只有兩個元素，將第一個元素留空，其餘兩個元素填入 main 列表的 [5, '', temp[0], temp[1]] 中

#數字 5 代表著每一行指令的虛擬行號（line number）。每處理一行指令，就將虛擬行號增加 5。
#這樣的行號計算方式可能是為了在後續的處理中更容易區分不同行的指令。

macro = {}      # 儲存巨集的字典
in_macro = [False, '']  
"""包含兩個元素的列表，用於追蹤是否當前正在處理巨集。
第一個元素是一個布林值，表示是否在巨集定義中
（True 表示在巨集定義中，False 表示不在）。
第二個元素是字串，表示目前正在處理的巨集的名稱。"""

line = 5
for i in Input[1:]:
    line += 5
#將 line 變數增加 5。這樣的操作可能是為了在後續的指令處理中，為每一行指令分配一個虛擬的行號

    if (i[0] == '.'):
        continue
#檢查 i 中的第一個元素是否為句點.，如果是即為註解行跳過

    # 分割每一行的指令
    i = i.replace('\n', '').split(' ')
#將字符串 i 中的換行符號 \n 替換為空字符串，使用空格作為分隔符，將處理過的字符串 i 分割為一個列表

    # 根據指令數量，初始化 now 列表
    if (len(i) == 1):
        now = [line, '', i[0], '']
    #長度為一時，now列表將初始化，line 是虛擬行號，i[0] 是指令的主要部分，'' 是指令的其他部分
    elif (len(i) == 2):
        now = [line, '', i[0], i[1]]
    #長度為二時，now列表將初始化，line 是虛擬行號，i[0] 是指令的主要部分，i[2] 是指令的其他部分
    else:
        now = [line, i[0], i[1], i[2]]
    #i 列表的長度大於等於3，line 是虛擬行號，i[0]、i[1]、i[2] 分別是指令的主要和其他部分。

    # 如果進入了巨集定義
    if (now[2] == 'MACRO'):#判斷是否為 'MACRO'
        in_macro = [True, now[1]]
        #in_macro值更新，標記正在處理巨集。True表示正在巨集定義中，而 now[1] 是目前巨集的名稱。
        macro[now[1]] = [now[3].split(','), []]
        """將巨集的名稱和參數存入 macro 字典。now[1] 是巨集的名稱，now[3] 是巨集的參數部分，
        使用 split(',') 方法將參數以逗號分割成一個列表。巨集的指令部分初始化為空列表 []。"""
        continue
            #檢測到 'MACRO' 指令後，直接進入下一次迴圈的迭代，跳過後續的指令處理
    
    elif (now[2] == 'MEND'):#檢查指令主要部分是否為 'MEND'。
        in_macro = [False, '']
        """將 in_macro 列表的值更新，標記目前離開了巨集定義。False 表示不在巨集定義中，
        而 'MEND' 指令本身不需要特別的名稱，所以第二個元素設為空字符串。"""
        continue
    #直接進入下一次迴圈，因為 'MEND' 指令標誌著巨集定義的結束

    # 如果正在巨集定義中
    if in_macro[0]:
        #檢查是否在巨集定義中（True 表示正在巨集定義中） 
        macro[in_macro[1]][1].append(now)
        """將當前的指令 now 添加到巨集的指令列表中，用
        in_macro[1] 得到當前巨集的名稱，然後使用 macro[in_macro[1]][1] 取得該巨集的指令列表，
        再使用 append(now) 將當前指令添加到該列表中"""
    else:#不在巨集定義中的情況下執行以下的程式碼
        if now[2] in macro:
        #檢查 now 列表中指令部分是否是一個已經定義好的巨集名稱，即是否存在於 macro 字典中。

            function_ = now[1]
            #將 now 列表中的第二個元素（指令的其他部分）賦值給 function_ 變數

            if (now[1]) != '':
            #檢查 now 列表中的第二個元素是否不為空
                now[1] = f'.{now[1]}'
            #如果指令的其他部分存在，則將其加上句點前綴，例如將 'MY_MACRO' 轉換為 '.MY_MACRO'。
            
            main.append(now.copy())
            #now 的複製添加到 main 列表中替換巨集名稱
            
            # 處理巨集的參數替換
            parms = {}#字典，儲存巨集的參數
            now[3] = now[3].split(',')
            #now 列表中的第四個元素（指令的操作數）使用逗號分割，轉換為一個列表，。為了後續處理巨集的參數替換
            
            for n, p in enumerate(macro[now[2]][0]):
            #巨集的參數列表。n 是索引，p 是參數名稱。
                parms[p] = now[3][n]
            #now[3] 是指令中的操作數部分，而 n 是迴圈的索引，所以這行程式碼的作用是將巨集中的參數和對應的實際值進行映射。    
            """當後續的指令中遇到巨集的使用時，需要將巨集的參數替換為實際的值。這個映射就提供了一個方便的方式，
            可以根據參數名稱查找對應的實際值，然後進行替換。"""
            
            # 將展開的巨集指令加入 main 列表
            macro[now[2]][1][0][1] = function_
            """將巨集展開後的指令列表中的第一個指令（通常是 MACRO 指令的別名指令）的第二個元素設置為 function_。
            這是在處理巨集展開時，將巨集別名應用到展開的指令中。"""
            for n, j in enumerate(macro[now[2]][1]):#巨集的指令列表
                j = j.copy()#複製巨集指令
                j[0] = str(line) + chr(ord('a')+n)
                #將展開後的標識指令位置，修改為新的虛擬行號
                #line 是在前面處理中用來標識每一行指令的虛擬行號，n 是迴圈的索引。
                for k in parms.keys():
                    if k in j[3]:
                        j[3] = j[3].replace(k, parms[k])
                """處理展開後的指令中的參數替換。對於指令的操作數 j[3] 中的每一個參數名稱 k，
                如果 k 存在於 parms 字典的鍵中，則將 j[3] 中的 k 替換為 parms[k]。"""
                main.append(j.copy())
                #處理完的指令 j 添加到 main 列表中。展開的指令逐一加入主程式的指令列表。

        else:
            main.append(now)
            #當指令不是巨集定義、也不是需要展開的指令時，直接將該指令加入到主程式的指令列表中


# 輸出結果
print(" %-10s %-10s %-10s %-10s"%('Line', '', 'Original', ''))
for i in main:
    if (i[1] == '.'):
        print(" %-10s %-10s %-10s %-39s"%(i[0], i[1], i[2], i[3]))
        #檢查指令中的第二個元素（即 i[1]）是否為 '.'。如果是，則使用格式化的方式打印該指令的虛擬行號 i[0]、空白、指令主要部分 i[2]、指令的其他部分 i[3]，確保對齊。
    else:
        print(" %-10s %-10s %-10s %-10s"%(i[0], i[1], i[2], i[3]))
        #使用格式化的方式打印該指令的虛擬行號 i[0]、指令的其他部分 i[1]、指令主要部分 i[2]、指令的其他部分 i[3]